from rawgl import gl as _gl

def _get_default_context():
    """Grab the default context from the L{context} module.

    The import is wrapped in a function definition to avoid infinite recursion
    on import because the L{context} module imports this module.
    """

    from glitter.contexts import get_default_context
    return get_default_context()

class GLObject(object):
    """Base class for objects that belong to an OpenGL context.
    """

    def __init__(self, context=None):
        self._context = context or _get_default_context() #: the parent context

class ManagedObject(GLObject): # inherit from BindableObject, then ManagedObject!
    """Base class for objects that can be created and deleted in OpenGL.

    When a C{ManagedObject} instance is garbage collected, the corresponding
    OpenGL object is deleted as well.
    
    For each C{ManagedObject} subclass, the context keeps a database of existing
    objects.
    """

    _generate_id = NotImplemented #: constructor function, e.g. glGenShader
    _delete_id = NotImplemented #: destructor function, e.g. glDeleteShader
    _type = NotImplemented #: type (if any), e.g. GL_VERTEX_SHADER
    _db = NotImplemented #: name of corresponding object database in context, e.g. "shaders"

    def __init__(self, context=None):
        if any(x is NotImplemented for x in (self._generate_id, self._delete_id)):
            raise TypeError("%s is abstract" % self.__class__.__name__)
        super(ManagedObject, self).__init__(context)
        with self._context:
            if hasattr(self._generate_id, "argtypes") and len(self._generate_id.argtypes) == 1:
                self._id = self._generate_id(self._type) #: ID generated by OpenGL, unique per context
            elif hasattr(self._generate_id, "argtypes") and len(self._generate_id.argtypes) == 2:
                _id = _gl.GLuint()
                self._generate_id(1, _gl.pointer(_id))
                self._id = _id.value
            else:
                self._id = self._generate_id()
        if self._db is not NotImplemented:
            getattr(self._context, self._db)._objects[self._id] = self

    def __del__(self):
        try:
            with self._context:
                if hasattr(self._delete_id, "argtypes") and len(self._delete_id.argtypes) == 2:
                    self._delete_id(1, _gl.pointer(_gl.GLuint(self._id)))
                else:
                    self._delete_id(self._id)
            self._id = 0
        except:
            pass

class BindableObject(GLObject):
    """Base class for objects that can be bound.

    When the object is bound, it returns the object that was previously bound
    to the same target.

    C{BindableObject} instances can be used in C{with} statements so that binding
    and resetting the previous state happens automatically.

    If subclasses define the methods L{_on_bind} or L{_on_release}, these will be
    called by the binding handler in the context whenever the instance is bound
    or unbound, respectively.

    If subclasses define a property C{_bind_value}, this value will be passed to
    the binding function instead of C{self}.

    Binding of an object to different targets (e.g. buffers that are bound to
    different targets, framebuffers that are bound for reading or drawing, and
    textures that are bound to different texture image units) is not covered by
    the C{BindableObject} class.
    """

    _binding = NotImplemented #: name of corresponding property in context, e.g. "array_buffer_binding"
    _on_bind = NotImplemented #: callback before binding
    _on_release = NotImplemented #: callback after releasing

    def __init__(self, context=None):
        super(BindableObject, self).__init__(context)
        if any(x is NotImplemented for x in (self._binding,)):
            raise TypeError("%s is abstract" % self.__class__.__name__)
        self._stack = []
    
    def bind(self):
        """Bind the object and return the previously bound object.

        Binding is executed by the corresponding properties of the context
        object.
        """

        old_binding = getattr(self._context, self._binding)
        setattr(self._context, self._binding, self._bind_value if hasattr(self, "_bind_value") else self)
        return old_binding

    def __enter__(self):
        self._context.__enter__()
        self._stack.append(self.bind())

    def __exit__(self, type, value, traceback):
        old_binding = self._stack.pop()
        setattr(self._context, self._binding, old_binding)
        self._context.__exit__(type, value, traceback)

class Reset(BindableObject):
    """Helper class to add binding semantics to context property changes.

    To set a property of the context and automatically reset it to its old
    value later, use a C{with} statement with a C{Reset} object.
    """

    def __init__(self, context, prop, value):
        """Create a C{Reset} object for use in C{with} statements.

        When entering the C{with} statement, the property C{prop} of L{context}
        C{context} will be set to C{value}. On exiting the C{with} statement, the
        old value will be restored.
        """

        self._binding = prop
        self._bind_value = value
        super(Reset, self).__init__(context)

class BindReleaseObject(GLObject):
    """Base class for objects that can be bound and released.

    C{BindReleaseObject} should be used instead of L{BindableObject} when binding
    and releasing are not performed by setting a property on a context, but by
    custom L{bind} and L{release} methods.

    Subclasses are responsible for restoring any objects previously bound to
    the same target.
    """

    bind = NotImplemented #: method for binding self (no arguments)
    release = NotImplemented #: method for releasing self (no arguments)

    def __init__(self, context=None):
        super(BindReleaseObject, self).__init__(context)
        if any(x is NotImplemented for x in (self.bind, self.release)):
            raise TypeError("%s is abstract" % self.__class__.__name__)
    
    def __enter__(self):
        self._context.__enter__()
        self.bind()

    def __exit__(self, type, value, traceback):
        self.release()
        self._context.__exit__(type, value, traceback)

__all__ = ["GLObject", "ManagedObject", "BindableObject", "BindReleaseObject", "Reset"]

