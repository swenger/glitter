"""Base classes for OpenGL objects.

@author: Stephan Wenger
@date: 2012-02-29
"""

from rawgl import gl as _gl

def _get_current_context():
    """Grab the current context from the L{context} module.

    The import is wrapped in a function definition to avoid infinite recursion
    on import because the L{context} module imports this module.
    """

    from glitter.contexts import get_current_context
    return get_current_context()

class GLObject(object):
    """Base class for objects that belong to an OpenGL context.

    @ivar _context: The parent context.
    """

    def __init__(self, context=None):
        """Create a new C{GLObject}.

        @param context: The parent context. Uses the current context if C{context} is C{None}.
        @type context: L{Context}.
        """

        self._context = context or _get_current_context()

class ManagedObject(GLObject):
    """Base class for objects that can be created and deleted in OpenGL.

    When a C{ManagedObject} instance is garbage collected, the corresponding
    OpenGL object is deleted as well.
    
    For each C{ManagedObject} subclass, the context keeps a database of existing
    objects.

    When inheriting from L{BindableObject} and C{ManagedObject} at the same
    time, inherit from L{BindableObject} first to obtain the correct ordering
    for constructor calls.

    @ivar _id: ID generated by OpenGL. The ID is only unique per context.
    """

    _generate_id = NotImplemented
    """Constructor function.
    
    Example: C{glGenShader}

    If the function has an C{argtypes} attribute, it may have zero, one, or two
    parameters. If it has one parameter, L{_type} is passed as the parameter,
    and the return value is used as L{_id}.  If it has two parameters, C{1} is
    passed as the first and a C{GLuint} pointer as the second parameter; the
    number returned in this pointer is used as the L{_id}. All other functions
    are simply called and their return values used as L{_id}.
    """
    
    _delete_id = NotImplemented
    """Destructor function.
    
    Example: C{glDeleteShader}

    If the function has an C{argtypes} attribute and two arguments, C{1} is
    passed as the first and a C{GLuint} pointer to L{_id} as the second
    parameter.  Otherwise, L{_id} is passed as the only parameter.
    """

    _type = NotImplemented
    """An optional parameter for C{_generate_id}.
    
    Example: C{GL_VERTEX_SHADER}
    """

    _db = NotImplemented
    """The name of the corresponding object database in the L{Context}.
    
    Example: C{"shaders"}
    """

    def __init__(self, context=None):
        """Create a new C{ManagedObject} using L{_generate_id}.

        @param context: The parent context.
        @type context: L{Context}.
        """

        if any(x is NotImplemented for x in (self._generate_id, self._delete_id)):
            raise TypeError("%s is abstract" % self.__class__.__name__)
        super(ManagedObject, self).__init__(context)
        with self._context:
            if hasattr(self._generate_id, "argtypes") and len(self._generate_id.argtypes) == 1:
                self._id = self._generate_id(self._type)
            elif hasattr(self._generate_id, "argtypes") and len(self._generate_id.argtypes) == 2:
                _id = _gl.GLuint()
                self._generate_id(1, _gl.pointer(_id))
                self._id = _id.value
            else:
                self._id = self._generate_id()
        if self._id == 0:
            raise RuntimeError("could not create %s" % self.__class__.__name__)
        if self._db is not NotImplemented:
            getattr(self._context, self._db)._objects[self._id] = self

    def __del__(self):
        """Delete the OpenGL object using L{_delete_id}.

        Any errors will be ignored because the OpenGL module may already have
        been garbage collected when the interpreter exits.
        """

        try:
            with self._context:
                if hasattr(self._delete_id, "argtypes") and len(self._delete_id.argtypes) == 2:
                    self._delete_id(1, _gl.pointer(_gl.GLuint(self._id)))
                else:
                    self._delete_id(self._id)
            self._id = 0
        except:
            pass

class BindableObject(GLObject):
    """Base class for objects that can be bound.

    When the object is bound, it returns the object that was previously bound
    to the same target.

    C{BindableObject} instances can be used in C{with} statements so that binding
    and resetting the previous state happens automatically.

    If subclasses define the methods L{_on_bind} or L{_on_release}, these will be
    called by the binding handler in the context whenever the instance is bound
    or unbound, respectively.

    If subclasses define a property C{_bind_value}, this value will be passed to
    the binding function instead of C{self}.

    Binding of an object to different targets (e.g. buffers that are bound to
    different targets, framebuffers that are bound for reading or drawing, and
    textures that are bound to different texture image units) is not covered by
    the C{BindableObject} class.

    When inheriting from C{BindableObject} and L{ManagedObject} at the same
    time, inherit from C{BindableObject} first to obtain the correct ordering
    for constructor calls.

    @ivar _stack: A stack for storing previous bindings within C{with}
    statements.
    """

    _binding = NotImplemented
    """Name of the corresponding property in the L{Context}.

    Example: C{"array_buffer_binding"}
    """

    _on_bind = NotImplemented
    """Function to call before binding.
    
    L{ShaderProgram}s, for example, bind textures here.
    """
    
    _on_release = NotImplemented
    """Function to call after releasing.

    L{ShaderProgram}s, for example, release textures here.
    """

    _bind_value = NotImplemented
    """Value to pass to the C{_binding} property.

    If C{NotImplemented}, C{self} will be used.
    """

    def __init__(self, context=None):
        """Create a new C{BindableObject}.

        @param context: The parent context.
        @type context: L{Context}.
        """

        super(BindableObject, self).__init__(context)
        if any(x is NotImplemented for x in (self._binding,)):
            raise TypeError("%s is abstract" % self.__class__.__name__)
        self._stack = []
    
    def bind(self):
        """Bind the object and return the previously bound object.

        Binding is executed by setting the parent L{Context}'s property named
        in L{_binding}.

        @return: The previous value of the property.
        """

        old_binding = getattr(self._context, self._binding)
        setattr(self._context, self._binding, self if self._bind_value is NotImplemented else self._bind_value)
        return old_binding

    def __enter__(self):
        """Called when a C{with} statement is entered.

        Activates the parent L{Context}, calls L{bind} and stores the returned
        value on the L{_stack}.
        """

        self._context.__enter__()
        self._stack.append(self.bind())
        return self

    def __exit__(self, type, value, traceback):
        """Called when a C{with} statement is exited.

        Restores the previous binding from the L{_stack} by setting the
        attribute named in L{_binding} in the parent L{Context} and deactivates
        the parent L{Context}.
        """

        old_binding = self._stack.pop()
        setattr(self._context, self._binding, old_binding)
        self._context.__exit__(type, value, traceback)

class Reset(BindableObject):
    """Helper class to add binding semantics to context property changes.

    To set a property of the context and automatically reset it to its old
    value later, use a C{with} statement with a C{Reset} object.
    """

    def __init__(self, context, prop, value):
        """Create a C{Reset} object for use in C{with} statements.

        When entering the C{with} statement, the property C{prop} of C{context}
        will be set to C{value}. On exiting the C{with} statement, the old
        value will be restored.
        """

        self._binding = prop
        self._bind_value = value
        super(Reset, self).__init__(context)

class BindReleaseObject(GLObject):
    """Base class for objects that can be bound and released.

    C{BindReleaseObject} should be used instead of L{BindableObject} when binding
    and releasing are not performed by setting a property on a context, but by
    custom L{bind} and L{release} methods.

    Subclasses are responsible for restoring any objects previously bound to
    the same target.
    """

    bind = NotImplemented
    """Method for binding C{self} to L{_context}.

    C{bind} takes no arguments.
    """

    release = NotImplemented
    """Method for releasing C{self} from L{_context}.

    C{release} is responsible for restoring any previous binding.

    C{release} takes no arguments.
    """

    def __init__(self, context=None):
        """Create a new C{BindReleaseObject}.

        @param context: The parent context.
        @type context: L{Context}.
        """

        super(BindReleaseObject, self).__init__(context)
        if any(x is NotImplemented for x in (self.bind, self.release)):
            raise TypeError("%s is abstract" % self.__class__.__name__)
    
    def __enter__(self):
        """Called when a C{with} statement is entered.

        Activates the parent L{Context} and calls L{bind}.
        """

        self._context.__enter__()
        self.bind()
        return self

    def __exit__(self, type, value, traceback):
        """Called when a C{with} statement is exited.

        Calls L{release} and deactivates the parent L{Context}.
        """

        self.release()
        self._context.__exit__(type, value, traceback)

__all__ = ["GLObject", "ManagedObject", "BindableObject", "BindReleaseObject", "Reset"]

