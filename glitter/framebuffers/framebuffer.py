"""Framebuffer object class.

@author: Stephan Wenger
@date: 2012-02-29
"""

from itertools import izip_longest as _zip
from rawgl import gl as _gl

from glitter.utils import BindableObject, ManagedObject, constants

# TODO raise exception when bound for drawing but status is not COMPLETE
# TODO binding as read_framebuffer_binding, glBlitFramebuffer, glCopyTexSubImage

class Framebuffer(BindableObject, ManagedObject):
    _generate_id = _gl.glGenFramebuffers
    _delete_id = _gl.glDeleteBuffers
    _db = "framebuffers"
    _binding = "draw_framebuffer_binding"
    _target = _gl.GL_DRAW_FRAMEBUFFER

    framebuffer_status = constants.framebuffer_status

    def __init__(self, attachments=[], depth=None, stencil=None):
        super(Framebuffer, self).__init__()
        self._attachments = {}
        for i, attachment in _zip(range(self._context.max_color_attachments), attachments, fillvalue=None):
            self[i] = attachment
        self.depth = depth
        self.stencil = stencil

    def __getitem__(self, index):
        return self._attachments[index]

    def __setitem__(self, index, value):
        self.attach(index, value)

    def __delitem__(self, index):
        self.attach(index, None)

    def _on_bind(self):
        self._stack.append(self._context.draw_buffers)
        self._context.draw_buffers = [i if self[i] is not None else None for i in range(len(self._attachments))]
        # TODO does this work correctly during __init__?
        # TODO set viewport, color_writemask, depth_writemask, blend_func, blend_equation, depth_range

    def _on_release(self):
        # TODO reset viewport, color_writemask, depth_writemask, blend_func, blend_equation, depth_range
        self._context.draw_buffers = self._stack.pop()

    def _attach(self, attachment, texture=None, layer=None, level=0):
        """Attach a texture to an attachment.

        C{texture} may be a (texture, layer) tuple generated by
        L{Texture}C{.__getitem__()}.
        """

        if type(texture) is tuple:
            if layer is not None:
                raise ValueError("cannot provide layer as both keyword and texture tuple")
            texture, layer = texture
            return self._attach(attachment, texture, layer, level)

        with self:
            if texture is None:
                _gl.glFramebufferTextureLayer(self._target, attachment, 0, level, 0)
            elif layer is None:
                _gl.glFramebufferTexture(self._target, attachment, texture._id, level)
            else:
                _gl.glFramebufferTextureLayer(self._target, attachment, texture._id, level, layer)

    def attach(self, index, texture=None, layer=None, level=0):
        """Attach a texture to color attachment C{index}.

        C{texture} may be a (texture, layer) tuple generated by
        L{Texture}C{.__getitem__()}.  Otherwise, C{layer} specifies which
        texture layer is to be bound. All layers are bound when C{layer} is
        C{None}.

        C{level} specifies which resolution level of the texture is to be
        bound.

        If C{texture} is C{None}, the attachment will be unbound.
        """

        self._attach(_gl.GL_COLOR_ATTACHMENT0 + index, texture, layer, level)
        self._attachments[index] = texture

    # TODO properties for viewport, color_writemask, depth_writemask, blend_func, blend_equation, depth_range (glDepthRangeArray, glDepthRangeIndexed)

    @property
    def depth(self):
        return self._depth

    @depth.setter
    def depth(self, depth):
        self.attach_depth(depth)

    @depth.deleter
    def depth(self):
        self.attach_depth(None)

    def attach_depth(self, texture=None, layer=None, level=0):
        """Attach a texture to the depth attachment.

        C{texture} may be a (texture, layer) tuple generated by
        L{Texture}C{.__getitem__()}.  Otherwise, C{layer} specifies which
        texture layer is to be bound. All layers are bound when C{layer} is
        C{None}.

        C{level} specifies which resolution level of the texture is to be
        bound.

        If C{texture} is C{None}, the attachment will be unbound.
        """

        self._attach(_gl.GL_DEPTH_ATTACHMENT, texture, layer, level)
        self._depth = texture

    @property
    def stencil(self):
        return self._stencil

    @stencil.setter
    def stencil(self, stencil):
        self.attach_stencil(stencil)

    @stencil.deleter
    def stencil(self):
        self.attach_stencil(None)

    def attach_stencil(self, texture=None, layer=None, level=0):
        """Attach a texture to the stencil attachment.

        C{texture} may be a (texture, layer) tuple generated by
        L{Texture}C{.__getitem__()}.  Otherwise, C{layer} specifies which
        texture layer is to be bound. All layers are bound when C{layer} is
        C{None}.

        C{level} specifies which resolution level of the texture is to be
        bound.

        If C{texture} is C{None}, the attachment will be unbound.
        """

        self._attach(_gl.GL_STENCIL_ATTACHMENT, texture, layer, level)
        self._stencil = texture

    @property
    def status(self):
        """The framebuffer completeness status.

        @rtype: L{Framebuffer.framebuffer_status} enum
        """

        with self:
            return self.framebuffer_status[_gl.glCheckFramebufferStatus(self._target)]

    def clear(self, color=None, depth=None, stencil=None): # TODO glClearBuffer for clearing selected attachments
        with self:
            self._context._clear(color, depth, stencil)

__all__ = ["Framebuffer"]

